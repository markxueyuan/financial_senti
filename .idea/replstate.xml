<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1462907141234">{:repl-history {:ide [], :local [&quot;(convert-variable \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n                    :isin :permno\n                    :zz\n                    match-permno)&quot; &quot;(ns financial-senti.mongo\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [monger.operators :refer :all]\n            [clojure.java.io :as io]\n            [clojure.data.csv :as csv]\n            [financial-senti.time :as t]\n            [incanter.stats :as s])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           org.bson.types.ObjectId))\n\n#_(defn directory\n    []\n    (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export\&quot;))\n\n(defn directory\n  []\n  (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export2\&quot;))\n\n\n(defn files\n  []\n  (file-seq (directory)))\n\n(defn lazy-read-csv\n  [csv-file]\n  (let [in-file (io/reader csv-file)\n        csv-seq (csv/read-csv in-file)\n        lazy (fn lazy [wrapped]\n               (lazy-seq\n                 (if-let [s (seq wrapped)]\n                   (cons (first s) (lazy (rest s)))\n                   (.close in-file))))]\n    (lazy csv-seq)))\n\n(defn lazy-read-csv-head-on\n  [file]\n  (let [coll (lazy-read-csv file)\n        head (map keyword (first coll))\n        rows (rest coll)]\n    (map #(zipmap head %) rows)))\n\n(defn write-to-mongo-in-batch\n  [db coll lazy-data]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/insert-batch db coll lazy-data)))\n\n(defn write-first-to-mongo\n  [db coll]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        f (first (rest (files)))]\n    (doseq [d (lazy-read-csv-head-on f)]\n      (mc/insert db coll (assoc d :_id (ObjectId.))))))\n\n\n(defn unique-index\n  [db coll key]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (array-map key 1) {:unique true})))\n\n(defn ensure-index\n  [db coll &amp; keyvals]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (apply array-map keyvals))))\n\n\n#_(defn update-to-mongo\n    [db coll identi]\n    (let [conn (mg/connect)\n          db (mg/get-db conn db)\n          a (atom 0)]\n      (doseq [f (doall (rest (rest (files))))]\n        (doseq [d (lazy-read-csv-head-on f)]\n          (mc/update db coll {identi (get d identi)}\n                     {$set d} {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print d))))))\n\n(defn update-to-mongo\n  [db coll identi]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (doseq [f (doall (rest (files)))]\n      (doseq [d (lazy-read-csv-head-on f)]\n        (mc/update db coll {identi (get d identi)}\n                   {$set d} {:upsert true})\n        (swap! a inc)\n        (if (= 0 (mod @a 5000))\n          (print d))))))\n\n(defn convert-date\n  [db coll old-date new-date index]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-date (t/parse-date (get % old-date))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-date])))))\n\n(defn read-into-memory\n  \&quot;Used to read unique values of 2 fields into memory\&quot;\n  [db coll &amp; ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (apply\n      (partial conj {})\n      (doall\n        (map\n          (apply juxt ks)\n          (mc/find-maps db coll {} ks))))))\n\n(defn find-one\n  [db coll cond ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/find-one-as-map db coll cond ks)))\n\n(defn convert-variable\n  [db coll old-v new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func (get % old-v))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-v])))))\n\n(defn convert-variables\n  [db coll old-vs new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func ((apply juxt old-vs)\n                                          %))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} (conj old-vs index))))))\n\n(def index (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno\n  [isin]\n  (when (&gt; (count isin) 8)\n    (let [issuer_cusip (subs isin 2 8)]\n      (get index issuer_cusip))))\n\n(defn match-permno-general\n  [index key [head end]]\n  (let [index (read-into-memory \&quot;finance\&quot; index\n                                :issuer_cusip\n                                :permno)]\n    (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip))))\n\n(def match-cusip-permno\n  (fn [cusip]\n    (match-permno-general \&quot;index2\&quot; cusip [0 6])))\n\n(def match-isin-permno\n  (fn [isin]\n    (match-permno-general \&quot;index2\&quot; isin [2 8])))\n\n\n\n(defn query-date-span\n  [db coll date-v match-v]                         ;target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [target-v start end stat-func]             ;time span\n      (fn [[date match]]                           ;function as input of convert-variables\n        (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n          (let [span (t/date-span start end date)]\n            (-&gt;&gt;\n              (mc/find-maps\n                db coll\n                {match-v match\n                 date-v  {$gte (first span)\n                          $lte (second span)}}\n                [target-v])\n              (map target-v)\n              stat-func)))))))\n\n(defn query-cond-date-span\n  [db coll date-v match-v]                                  ;define target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [cond-vs filter-func]                               ;define conditions by other variables\n      (fn [target-v start end stat-func]                    ;define time span\n        (fn [[date match]]                                  ;return function as input of function convert-variables\n          (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n            (let [span (t/date-span start end date)]\n              (-&gt;&gt;\n                (mc/find-maps\n                  db coll\n                  {match-v match\n                   date-v  {$gte (first span)\n                            $lte (second span)}}\n                  (conj cond-vs target-v))\n                (filter-func cond-vs target-v)\n                stat-func))))))))\n\n\n(defn ignore-nil\n  [func]\n  (fn [input]\n    (when (and input (&gt; (count input) 0))\n      (func input))))\n\n(defn filter-nil\n  [func]\n  (fn [input]\n    (let [l (remove nil? input)]\n      (when (next l)\n        (func l)))))\n\n\n(defn to-catch\n  [func]\n  (fn [input]\n    (-&gt;&gt; input\n         (map (ignore-nil read-string))\n         (#((filter-nil func) %))\n         )))\n\n(def median (to-catch s/median))\n(def mean (to-catch s/mean))\n\n\n(defn filter-by-other-conds\n  [pred-func]\n  (fn [[unique-v filter-v] target-v data]\n    (let [data (filter\n                 #(pred-func (get % filter-v))\n                 data)\n          acm {target-v [] unique-v #{}}]\n      (get\n        (reduce\n          (fn [acm el]\n            (let [a (target-v acm)\n                  b (unique-v acm)\n                  c (target-v el)\n                  d (unique-v el)]\n              (if (get b d)\n                {target-v a unique-v b}\n                {target-v (conj a c) unique-v (conj b d)})))\n          acm data)\n        target-v))))\n\n(defn is-press-release\n  [value]\n  (= value \&quot;PRESS-RELEASE\&quot;))&quot; &quot;(defn match-permno-general\n  [index key [head end]]\n  (let [index (read-into-memory \&quot;finance\&quot; index\n                                :issuer_cusip\n                                :permno)]\n    (when (&gt; (count isin) 8)\n      (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip)))))&quot; &quot;(defn match-permno-general\n  [index key [head end]]\n  (let [index (read-into-memory \&quot;finance\&quot; index\n                                :issuer_cusip\n                                :permno)]\n    (when (&gt; (count key) 8)\n      (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip)))))&quot; &quot;(def match-cusip-permno\n  (fn [cusip]\n    (match-permno-general \&quot;index2\&quot; cusip [0 6])))&quot; &quot;(defn match-isin-permno\n  [isin]\n  (match-permno-general \&quot;index2\&quot; isin [2 8]))&quot; &quot;(defn convert-variable\n  [db coll old-v new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func (get % old-v))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-v])))))&quot; &quot;(ns financial-senti.mongo\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [monger.operators :refer :all]\n            [clojure.java.io :as io]\n            [clojure.data.csv :as csv]\n            [financial-senti.time :as t]\n            [incanter.stats :as s])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           org.bson.types.ObjectId))\n\n#_(defn directory\n    []\n    (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export\&quot;))\n\n(defn directory\n  []\n  (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export2\&quot;))\n\n\n(defn files\n  []\n  (file-seq (directory)))\n\n(defn lazy-read-csv\n  [csv-file]\n  (let [in-file (io/reader csv-file)\n        csv-seq (csv/read-csv in-file)\n        lazy (fn lazy [wrapped]\n               (lazy-seq\n                 (if-let [s (seq wrapped)]\n                   (cons (first s) (lazy (rest s)))\n                   (.close in-file))))]\n    (lazy csv-seq)))\n\n(defn lazy-read-csv-head-on\n  [file]\n  (let [coll (lazy-read-csv file)\n        head (map keyword (first coll))\n        rows (rest coll)]\n    (map #(zipmap head %) rows)))\n\n(defn write-to-mongo-in-batch\n  [db coll lazy-data]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/insert-batch db coll lazy-data)))\n\n(defn write-first-to-mongo\n  [db coll]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        f (first (rest (files)))]\n    (doseq [d (lazy-read-csv-head-on f)]\n      (mc/insert db coll (assoc d :_id (ObjectId.))))))\n\n\n(defn unique-index\n  [db coll key]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (array-map key 1) {:unique true})))\n\n(defn ensure-index\n  [db coll &amp; keyvals]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (apply array-map keyvals))))\n\n\n#_(defn update-to-mongo\n    [db coll identi]\n    (let [conn (mg/connect)\n          db (mg/get-db conn db)\n          a (atom 0)]\n      (doseq [f (doall (rest (rest (files))))]\n        (doseq [d (lazy-read-csv-head-on f)]\n          (mc/update db coll {identi (get d identi)}\n                     {$set d} {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print d))))))\n\n(defn update-to-mongo\n  [db coll identi]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (doseq [f (doall (rest (files)))]\n      (doseq [d (lazy-read-csv-head-on f)]\n        (mc/update db coll {identi (get d identi)}\n                   {$set d} {:upsert true})\n        (swap! a inc)\n        (if (= 0 (mod @a 5000))\n          (print d))))))\n\n(defn convert-date\n  [db coll old-date new-date index]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-date (t/parse-date (get % old-date))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-date])))))\n\n(defn read-into-memory\n  \&quot;Used to read unique values of 2 fields into memory\&quot;\n  [db coll &amp; ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (apply\n      (partial conj {})\n      (doall\n        (map\n          (apply juxt ks)\n          (mc/find-maps db coll {} ks))))))\n\n(defn find-one\n  [db coll cond ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/find-one-as-map db coll cond ks)))\n\n(defn convert-variable\n  [db coll old-v new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func (get % old-v))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-v])))))\n\n(defn convert-variables\n  [db coll old-vs new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func ((apply juxt old-vs)\n                                          %))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} (conj old-vs index))))))\n\n(def index (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno\n  [isin]\n  (when (&gt; (count isin) 8)\n    (let [issuer_cusip (subs isin 2 8)]\n      (get index issuer_cusip))))\n\n(defn match-permno-general\n  [index key [head end]]\n  (let [index (read-into-memory \&quot;finance\&quot; index\n                                :issuer_cusip\n                                :permno)]\n    (when (&gt; (count key) 8)\n      (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip)))))\n\n(def match-cusip-permno\n  (fn [cusip]\n    (match-permno-general \&quot;index2\&quot; cusip [0 6])))\n\n(defn match-isin-permno\n  [isin]\n  (match-permno-general \&quot;index2\&quot; isin [2 8]))\n\n\n\n(defn query-date-span\n  [db coll date-v match-v]                         ;target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [target-v start end stat-func]             ;time span\n      (fn [[date match]]                           ;function as input of convert-variables\n        (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n          (let [span (t/date-span start end date)]\n            (-&gt;&gt;\n              (mc/find-maps\n                db coll\n                {match-v match\n                 date-v  {$gte (first span)\n                          $lte (second span)}}\n                [target-v])\n              (map target-v)\n              stat-func)))))))\n\n(defn query-cond-date-span\n  [db coll date-v match-v]                                  ;define target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [cond-vs filter-func]                               ;define conditions by other variables\n      (fn [target-v start end stat-func]                    ;define time span\n        (fn [[date match]]                                  ;return function as input of function convert-variables\n          (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n            (let [span (t/date-span start end date)]\n              (-&gt;&gt;\n                (mc/find-maps\n                  db coll\n                  {match-v match\n                   date-v  {$gte (first span)\n                            $lte (second span)}}\n                  (conj cond-vs target-v))\n                (filter-func cond-vs target-v)\n                stat-func))))))))\n\n\n(defn ignore-nil\n  [func]\n  (fn [input]\n    (when (and input (&gt; (count input) 0))\n      (func input))))\n\n(defn filter-nil\n  [func]\n  (fn [input]\n    (let [l (remove nil? input)]\n      (when (next l)\n        (func l)))))\n\n\n(defn to-catch\n  [func]\n  (fn [input]\n    (-&gt;&gt; input\n         (map (ignore-nil read-string))\n         (#((filter-nil func) %))\n         )))\n\n(def median (to-catch s/median))\n(def mean (to-catch s/mean))\n\n\n(defn filter-by-other-conds\n  [pred-func]\n  (fn [[unique-v filter-v] target-v data]\n    (let [data (filter\n                 #(pred-func (get % filter-v))\n                 data)\n          acm {target-v [] unique-v #{}}]\n      (get\n        (reduce\n          (fn [acm el]\n            (let [a (target-v acm)\n                  b (unique-v acm)\n                  c (target-v el)\n                  d (unique-v el)]\n              (if (get b d)\n                {target-v a unique-v b}\n                {target-v (conj a c) unique-v (conj b d)})))\n          acm data)\n        target-v))))\n\n(defn is-press-release\n  [value]\n  (= value \&quot;PRESS-RELEASE\&quot;))&quot; &quot;(convert-variable \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n                  :isin :permno\n                  :zz\n                  match-isin-permno)&quot; &quot;(ns financial-senti.mongo\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [monger.operators :refer :all]\n            [clojure.java.io :as io]\n            [clojure.data.csv :as csv]\n            [financial-senti.time :as t]\n            [incanter.stats :as s])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           org.bson.types.ObjectId))\n\n#_(defn directory\n    []\n    (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export\&quot;))\n\n(defn directory\n  []\n  (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export2\&quot;))\n\n\n(defn files\n  []\n  (file-seq (directory)))\n\n(defn lazy-read-csv\n  [csv-file]\n  (let [in-file (io/reader csv-file)\n        csv-seq (csv/read-csv in-file)\n        lazy (fn lazy [wrapped]\n               (lazy-seq\n                 (if-let [s (seq wrapped)]\n                   (cons (first s) (lazy (rest s)))\n                   (.close in-file))))]\n    (lazy csv-seq)))\n\n(defn lazy-read-csv-head-on\n  [file]\n  (let [coll (lazy-read-csv file)\n        head (map keyword (first coll))\n        rows (rest coll)]\n    (map #(zipmap head %) rows)))\n\n(defn write-to-mongo-in-batch\n  [db coll lazy-data]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/insert-batch db coll lazy-data)))\n\n(defn write-first-to-mongo\n  [db coll]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        f (first (rest (files)))]\n    (doseq [d (lazy-read-csv-head-on f)]\n      (mc/insert db coll (assoc d :_id (ObjectId.))))))\n\n\n(defn unique-index\n  [db coll key]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (array-map key 1) {:unique true})))\n\n(defn ensure-index\n  [db coll &amp; keyvals]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (apply array-map keyvals))))\n\n\n#_(defn update-to-mongo\n    [db coll identi]\n    (let [conn (mg/connect)\n          db (mg/get-db conn db)\n          a (atom 0)]\n      (doseq [f (doall (rest (rest (files))))]\n        (doseq [d (lazy-read-csv-head-on f)]\n          (mc/update db coll {identi (get d identi)}\n                     {$set d} {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print d))))))\n\n(defn update-to-mongo\n  [db coll identi]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (doseq [f (doall (rest (files)))]\n      (doseq [d (lazy-read-csv-head-on f)]\n        (mc/update db coll {identi (get d identi)}\n                   {$set d} {:upsert true})\n        (swap! a inc)\n        (if (= 0 (mod @a 5000))\n          (print d))))))\n\n(defn convert-date\n  [db coll old-date new-date index]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-date (t/parse-date (get % old-date))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-date])))))\n\n(defn read-into-memory\n  \&quot;Used to read unique values of 2 fields into memory\&quot;\n  [db coll &amp; ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (apply\n      (partial conj {})\n      (doall\n        (map\n          (apply juxt ks)\n          (mc/find-maps db coll {} ks))))))\n\n(defn find-one\n  [db coll cond ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/find-one-as-map db coll cond ks)))\n\n(defn convert-variable\n  [db coll old-v new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func (get % old-v))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-v])))))\n\n(defn convert-variables\n  [db coll old-vs new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func ((apply juxt old-vs)\n                                          %))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} (conj old-vs index))))))\n\n(def index (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno\n  [isin]\n  (when (&gt; (count isin) 8)\n    (let [issuer_cusip (subs isin 2 8)]\n      (get index issuer_cusip))))\n\n(def index2 (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno-general\n  [index key [head end]]\n  (when (&gt; (count key) 8)\n    (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip))))\n\n(def match-cusip-permno\n  (fn [cusip]\n    (match-permno-general index2 cusip [0 6])))\n\n(defn match-isin-permno\n  [isin]\n  (match-permno-general index2 isin [2 8]))\n\n\n\n(defn query-date-span\n  [db coll date-v match-v]                         ;target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [target-v start end stat-func]             ;time span\n      (fn [[date match]]                           ;function as input of convert-variables\n        (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n          (let [span (t/date-span start end date)]\n            (-&gt;&gt;\n              (mc/find-maps\n                db coll\n                {match-v match\n                 date-v  {$gte (first span)\n                          $lte (second span)}}\n                [target-v])\n              (map target-v)\n              stat-func)))))))\n\n(defn query-cond-date-span\n  [db coll date-v match-v]                                  ;define target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [cond-vs filter-func]                               ;define conditions by other variables\n      (fn [target-v start end stat-func]                    ;define time span\n        (fn [[date match]]                                  ;return function as input of function convert-variables\n          (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n            (let [span (t/date-span start end date)]\n              (-&gt;&gt;\n                (mc/find-maps\n                  db coll\n                  {match-v match\n                   date-v  {$gte (first span)\n                            $lte (second span)}}\n                  (conj cond-vs target-v))\n                (filter-func cond-vs target-v)\n                stat-func))))))))\n\n\n(defn ignore-nil\n  [func]\n  (fn [input]\n    (when (and input (&gt; (count input) 0))\n      (func input))))\n\n(defn filter-nil\n  [func]\n  (fn [input]\n    (let [l (remove nil? input)]\n      (when (next l)\n        (func l)))))\n\n\n(defn to-catch\n  [func]\n  (fn [input]\n    (-&gt;&gt; input\n         (map (ignore-nil read-string))\n         (#((filter-nil func) %))\n         )))\n\n(def median (to-catch s/median))\n(def mean (to-catch s/mean))\n\n\n(defn filter-by-other-conds\n  [pred-func]\n  (fn [[unique-v filter-v] target-v data]\n    (let [data (filter\n                 #(pred-func (get % filter-v))\n                 data)\n          acm {target-v [] unique-v #{}}]\n      (get\n        (reduce\n          (fn [acm el]\n            (let [a (target-v acm)\n                  b (unique-v acm)\n                  c (target-v el)\n                  d (unique-v el)]\n              (if (get b d)\n                {target-v a unique-v b}\n                {target-v (conj a c) unique-v (conj b d)})))\n          acm data)\n        target-v))))\n\n(defn is-press-release\n  [value]\n  (= value \&quot;PRESS-RELEASE\&quot;))&quot; &quot;(convert-variable \&quot;finance\&quot; \&quot;fisd\&quot;\n                  :isin :permno_new\n                  :_id\n                  match-permno)&quot; &quot;(ns financial-senti.mongo\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [monger.operators :refer :all]\n            [clojure.java.io :as io]\n            [clojure.data.csv :as csv]\n            [financial-senti.time :as t]\n            [incanter.stats :as s])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           org.bson.types.ObjectId))\n\n#_(defn directory\n    []\n    (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export\&quot;))\n\n(defn directory\n  []\n  (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export2\&quot;))\n\n\n(defn files\n  []\n  (file-seq (directory)))\n\n(defn lazy-read-csv\n  [csv-file]\n  (let [in-file (io/reader csv-file)\n        csv-seq (csv/read-csv in-file)\n        lazy (fn lazy [wrapped]\n               (lazy-seq\n                 (if-let [s (seq wrapped)]\n                   (cons (first s) (lazy (rest s)))\n                   (.close in-file))))]\n    (lazy csv-seq)))\n\n(defn lazy-read-csv-head-on\n  [file]\n  (let [coll (lazy-read-csv file)\n        head (map keyword (first coll))\n        rows (rest coll)]\n    (map #(zipmap head %) rows)))\n\n(defn write-to-mongo-in-batch\n  [db coll lazy-data]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/insert-batch db coll lazy-data)))\n\n(defn write-first-to-mongo\n  [db coll]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        f (first (rest (files)))]\n    (doseq [d (lazy-read-csv-head-on f)]\n      (mc/insert db coll (assoc d :_id (ObjectId.))))))\n\n\n(defn unique-index\n  [db coll key]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (array-map key 1) {:unique true})))\n\n(defn ensure-index\n  [db coll &amp; keyvals]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (apply array-map keyvals))))\n\n\n#_(defn update-to-mongo\n    [db coll identi]\n    (let [conn (mg/connect)\n          db (mg/get-db conn db)\n          a (atom 0)]\n      (doseq [f (doall (rest (rest (files))))]\n        (doseq [d (lazy-read-csv-head-on f)]\n          (mc/update db coll {identi (get d identi)}\n                     {$set d} {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print d))))))\n\n(defn update-to-mongo\n  [db coll identi]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (doseq [f (doall (rest (files)))]\n      (doseq [d (lazy-read-csv-head-on f)]\n        (mc/update db coll {identi (get d identi)}\n                   {$set d} {:upsert true})\n        (swap! a inc)\n        (if (= 0 (mod @a 5000))\n          (print d))))))\n\n(defn convert-date\n  [db coll old-date new-date index]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-date (t/parse-date (get % old-date))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-date])))))\n\n(defn read-into-memory\n  \&quot;Used to read unique values of 2 fields into memory\&quot;\n  [db coll &amp; ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (apply\n      (partial conj {})\n      (doall\n        (map\n          (apply juxt ks)\n          (mc/find-maps db coll {} ks))))))\n\n(defn find-one\n  [db coll cond ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/find-one-as-map db coll cond ks)))\n\n(defn convert-variable\n  [db coll old-v new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func (get % old-v))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-v])))))\n\n(defn convert-variables\n  [db coll old-vs new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func ((apply juxt old-vs)\n                                          %))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} (conj old-vs index))))))\n\n(def index (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno\n  [isin]\n  (when (&gt; (count isin) 8)\n    (let [issuer_cusip (subs isin 2 8)]\n      (get index issuer_cusip))))\n\n(def index2 (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno-general\n  [index key [head end]]\n  (when (&gt; (count key) 8)\n    (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip))))\n\n(def match-cusip-permno\n  (fn [cusip]\n    (match-permno-general index2 cusip [0 6])))\n\n(defn match-isin-permno\n  [isin]\n  (match-permno-general index2 isin [2 8]))\n\n\n\n(defn query-date-span\n  [db coll date-v match-v]                         ;target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [target-v start end stat-func]             ;time span\n      (fn [[date match]]                           ;function as input of convert-variables\n        (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n          (let [span (t/date-span start end date)]\n            (-&gt;&gt;\n              (mc/find-maps\n                db coll\n                {match-v match\n                 date-v  {$gte (first span)\n                          $lte (second span)}}\n                [target-v])\n              (map target-v)\n              stat-func)))))))\n\n(defn query-cond-date-span\n  [db coll date-v match-v]                                  ;define target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [cond-vs filter-func]                               ;define conditions by other variables\n      (fn [target-v start end stat-func]                    ;define time span\n        (fn [[date match]]                                  ;return function as input of function convert-variables\n          (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n            (let [span (t/date-span start end date)]\n              (-&gt;&gt;\n                (mc/find-maps\n                  db coll\n                  {match-v match\n                   date-v  {$gte (first span)\n                            $lte (second span)}}\n                  (conj cond-vs target-v))\n                (filter-func cond-vs target-v)\n                stat-func))))))))\n\n\n(defn ignore-nil\n  [func]\n  (fn [input]\n    (when (and input (&gt; (count input) 0))\n      (func input))))\n\n(defn filter-nil\n  [func]\n  (fn [input]\n    (let [l (remove nil? input)]\n      (when (next l)\n        (func l)))))\n\n\n(defn to-catch\n  [func]\n  (fn [input]\n    (-&gt;&gt; input\n         (map (ignore-nil read-string))\n         (#((filter-nil func) %))\n         )))\n\n(def median (to-catch s/median))\n(def mean (to-catch s/mean))\n\n\n(defn filter-by-other-conds\n  [pred-func]\n  (fn [[unique-v filter-v] target-v data]\n    (let [data (filter\n                 #(pred-func (get % filter-v))\n                 data)\n          acm {target-v [] unique-v #{}}]\n      (get\n        (reduce\n          (fn [acm el]\n            (let [a (target-v acm)\n                  b (unique-v acm)\n                  c (target-v el)\n                  d (unique-v el)]\n              (if (get b d)\n                {target-v a unique-v b}\n                {target-v (conj a c) unique-v (conj b d)})))\n          acm data)\n        target-v))))\n\n(defn is-press-release\n  [value]\n  (= value \&quot;PRESS-RELEASE\&quot;))\n\n\n;;;;;;;;;;;;; save data to mongo ;;;;;;;;;\n\n;(write-first-to-mongo \&quot;finance\&quot; \&quot;rpus_rv\&quot;)\n;(unique-index \&quot;finance\&quot; \&quot;rpus_rv\&quot; :zz)\n;(update-to-mongo \&quot;finance\&quot; \&quot;rpus_rv\&quot; :zz)\n\n#_(write-to-mongo-in-batch\n    \&quot;finance\&quot; \&quot;index\&quot;\n    (lazy-read-csv-head-on \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\index.csv\&quot;))\n\n#_(write-to-mongo-in-batch\n  \&quot;finance\&quot; \&quot;index2\&quot;\n  (lazy-read-csv-head-on \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\index2.csv\&quot;))\n\n\n#_(write-to-mongo-in-batch\n    \&quot;finance\&quot; \&quot;fisd\&quot;\n    (lazy-read-csv-head-on \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\fisd.csv\&quot;))\n\n#_(write-to-mongo-in-batch\n    \&quot;finance\&quot; \&quot;dsenames\&quot;\n    (lazy-read-csv-head-on \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\dsenames.csv\&quot;))\n\n\n;;;;;;;;;;;;;;;;;;; prepare data ;;;;;;;;;;;;;;;;;\n\n; index, permno, date\n\n#_(ensure-index \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n                :timestamp_utc 1)\n\n#_(convert-date \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n                :timestamp_utc :date\n                :zz)\n\n#_(convert-variable \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n                    :isin :permno\n                    :zz\n                    match-permno)\n\n#_(convert-variable \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n                  :isin :permno\n                  :zz\n                  match-isin-permno)\n\n\n#_(ensure-index \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n              :permno 1\n              :date 2)\n\n#_(convert-date \&quot;finance\&quot; \&quot;fisd\&quot;\n              :offering_date :date\n              :_id)\n\n#_(convert-variable \&quot;finance\&quot; \&quot;fisd\&quot;\n                  :isin :permno_new\n                  :_id\n                  match-permno)\n\n#_(convert-variable \&quot;finance\&quot; \&quot;fisd\&quot;\n                  :cusip :permno_new\n                  :_id\n                  match-cusip-permno)\n\n\n\n#_(def sentiment\n  (query-date-span\n    \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n    :date :permno))\n\n#_(def ess-before-30-median\n  (sentiment\n    :ess -30 -1 median))\n\n#_(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :ess_before_30_median\n  :_id ess-before-30-median)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :count_before_30\n  :_id count-before-30)&quot; &quot;(ns financial-senti.mongo\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [monger.operators :refer :all]\n            [clojure.java.io :as io]\n            [clojure.data.csv :as csv]\n            [financial-senti.time :as t]\n            [incanter.stats :as s])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           org.bson.types.ObjectId))\n\n#_(defn directory\n    []\n    (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export\&quot;))\n\n(defn directory\n  []\n  (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export2\&quot;))\n\n\n(defn files\n  []\n  (file-seq (directory)))\n\n(defn lazy-read-csv\n  [csv-file]\n  (let [in-file (io/reader csv-file)\n        csv-seq (csv/read-csv in-file)\n        lazy (fn lazy [wrapped]\n               (lazy-seq\n                 (if-let [s (seq wrapped)]\n                   (cons (first s) (lazy (rest s)))\n                   (.close in-file))))]\n    (lazy csv-seq)))\n\n(defn lazy-read-csv-head-on\n  [file]\n  (let [coll (lazy-read-csv file)\n        head (map keyword (first coll))\n        rows (rest coll)]\n    (map #(zipmap head %) rows)))\n\n(defn write-to-mongo-in-batch\n  [db coll lazy-data]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/insert-batch db coll lazy-data)))\n\n(defn write-first-to-mongo\n  [db coll]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        f (first (rest (files)))]\n    (doseq [d (lazy-read-csv-head-on f)]\n      (mc/insert db coll (assoc d :_id (ObjectId.))))))\n\n\n(defn unique-index\n  [db coll key]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (array-map key 1) {:unique true})))\n\n(defn ensure-index\n  [db coll &amp; keyvals]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (apply array-map keyvals))))\n\n\n#_(defn update-to-mongo\n    [db coll identi]\n    (let [conn (mg/connect)\n          db (mg/get-db conn db)\n          a (atom 0)]\n      (doseq [f (doall (rest (rest (files))))]\n        (doseq [d (lazy-read-csv-head-on f)]\n          (mc/update db coll {identi (get d identi)}\n                     {$set d} {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print d))))))\n\n(defn update-to-mongo\n  [db coll identi]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (doseq [f (doall (rest (files)))]\n      (doseq [d (lazy-read-csv-head-on f)]\n        (mc/update db coll {identi (get d identi)}\n                   {$set d} {:upsert true})\n        (swap! a inc)\n        (if (= 0 (mod @a 5000))\n          (print d))))))\n\n(defn convert-date\n  [db coll old-date new-date index]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-date (t/parse-date (get % old-date))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-date])))))\n\n(defn read-into-memory\n  \&quot;Used to read unique values of 2 fields into memory\&quot;\n  [db coll &amp; ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (apply\n      (partial conj {})\n      (doall\n        (map\n          (apply juxt ks)\n          (mc/find-maps db coll {} ks))))))\n\n(defn find-one\n  [db coll cond ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/find-one-as-map db coll cond ks)))\n\n(defn convert-variable\n  [db coll old-v new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func (get % old-v))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-v])))))\n\n(defn convert-variables\n  [db coll old-vs new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func ((apply juxt old-vs)\n                                          %))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} (conj old-vs index))))))\n\n(def index (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno\n  [isin]\n  (when (&gt; (count isin) 8)\n    (let [issuer_cusip (subs isin 2 8)]\n      (get index issuer_cusip))))\n\n(def index2 (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno-general\n  [index key [head end]]\n  (when (&gt; (count key) 8)\n    (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip))))\n\n(def match-cusip-permno\n  (fn [cusip]\n    (match-permno-general index2 cusip [0 6])))\n\n(defn match-isin-permno\n  [isin]\n  (match-permno-general index2 isin [2 8]))\n\n\n\n(defn query-date-span\n  [db coll date-v match-v]                         ;target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [target-v start end stat-func]             ;time span\n      (fn [[date match]]                           ;function as input of convert-variables\n        (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n          (let [span (t/date-span start end date)]\n            (-&gt;&gt;\n              (mc/find-maps\n                db coll\n                {match-v match\n                 date-v  {$gte (first span)\n                          $lte (second span)}}\n                [target-v])\n              (map target-v)\n              stat-func)))))))\n\n(defn query-cond-date-span\n  [db coll date-v match-v]                                  ;define target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [cond-vs filter-func]                               ;define conditions by other variables\n      (fn [target-v start end stat-func]                    ;define time span\n        (fn [[date match]]                                  ;return function as input of function convert-variables\n          (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n            (let [span (t/date-span start end date)]\n              (-&gt;&gt;\n                (mc/find-maps\n                  db coll\n                  {match-v match\n                   date-v  {$gte (first span)\n                            $lte (second span)}}\n                  (conj cond-vs target-v))\n                (filter-func cond-vs target-v)\n                stat-func))))))))\n\n\n(defn ignore-nil\n  [func]\n  (fn [input]\n    (when (and input (&gt; (count input) 0))\n      (func input))))\n\n(defn filter-nil\n  [func]\n  (fn [input]\n    (let [l (remove nil? input)]\n      (when (next l)\n        (func l)))))\n\n\n(defn to-catch\n  [func]\n  (fn [input]\n    (-&gt;&gt; input\n         (map (ignore-nil read-string))\n         (#((filter-nil func) %))\n         )))\n\n(def median (to-catch s/median))\n(def mean (to-catch s/mean))\n\n\n(defn filter-by-other-conds\n  [pred-func]\n  (fn [[unique-v filter-v] target-v data]\n    (let [data (filter\n                 #(pred-func (get % filter-v))\n                 data)\n          acm {target-v [] unique-v #{}}]\n      (get\n        (reduce\n          (fn [acm el]\n            (let [a (target-v acm)\n                  b (unique-v acm)\n                  c (target-v el)\n                  d (unique-v el)]\n              (if (get b d)\n                {target-v a unique-v b}\n                {target-v (conj a c) unique-v (conj b d)})))\n          acm data)\n        target-v))))\n\n(defn is-press-release\n  [value]\n  (= value \&quot;PRESS-RELEASE\&quot;))\n\n\n;;;;;;;;;;;;; save data to mongo ;;;;;;;;;\n\n;(write-first-to-mongo \&quot;finance\&quot; \&quot;rpus_rv\&quot;)\n;(unique-index \&quot;finance\&quot; \&quot;rpus_rv\&quot; :zz)\n;(update-to-mongo \&quot;finance\&quot; \&quot;rpus_rv\&quot; :zz)\n\n#_(write-to-mongo-in-batch\n    \&quot;finance\&quot; \&quot;index\&quot;\n    (lazy-read-csv-head-on \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\index.csv\&quot;))\n\n#_(write-to-mongo-in-batch\n  \&quot;finance\&quot; \&quot;index2\&quot;\n  (lazy-read-csv-head-on \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\index2.csv\&quot;))\n\n\n#_(write-to-mongo-in-batch\n    \&quot;finance\&quot; \&quot;fisd\&quot;\n    (lazy-read-csv-head-on \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\fisd.csv\&quot;))\n\n#_(write-to-mongo-in-batch\n    \&quot;finance\&quot; \&quot;dsenames\&quot;\n    (lazy-read-csv-head-on \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\dsenames.csv\&quot;))\n\n\n;;;;;;;;;;;;;;;;;;; prepare data ;;;;;;;;;;;;;;;;;\n\n; index, permno, date\n\n#_(ensure-index \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n                :timestamp_utc 1)\n\n#_(convert-date \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n                :timestamp_utc :date\n                :zz)\n\n#_(convert-variable \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n                    :isin :permno\n                    :zz\n                    match-permno)\n\n#_(convert-variable \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n                  :isin :permno\n                  :zz\n                  match-isin-permno)\n\n\n#_(ensure-index \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n              :permno 1\n              :date 2)\n\n#_(convert-date \&quot;finance\&quot; \&quot;fisd\&quot;\n              :offering_date :date\n              :_id)\n\n#_(convert-variable \&quot;finance\&quot; \&quot;fisd\&quot;\n                  :isin :permno_new\n                  :_id\n                  match-permno)\n\n#_(convert-variable \&quot;finance\&quot; \&quot;fisd\&quot;\n                  :cusip :permno_new\n                  :_id\n                  match-cusip-permno)\n\n\n\n#_(def sentiment\n  (query-date-span\n    \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n    :date :permno))\n\n#_(def ess-before-30-median\n  (sentiment\n    :ess -30 -1 median))\n\n#_(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :ess_before_30_median\n  :_id ess-before-30-median)\n\n(def sentiment\n  (query-cond-date-span\n    \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n    :date :permno))\n\n(def filter-func\n  (filter-by-other-conds is-press-release))\n\n(def the-filter\n  (sentiment [:rp_story_id :news_type] filter-func))        ;[unique-v filter-v]\n\n(def count-before-30\n  (the-filter :zz -30 -1 count))\n\n(def ess-before-30-median\n  (the-filter :ess -30 -1 median))&quot; &quot;(convert-variable \&quot;finance\&quot; \&quot;fisd\&quot;\n                  :cusip :permno_new\n                  :_id\n                  match-cusip-permno)&quot; &quot;(convert-variable \&quot;finance\&quot; \&quot;fisd\&quot;\n                  :isin :permno_new\n                  :_id\n                  match-isin-permno)&quot; &quot;(def ess-before-30-median\n  (the-filter :ess -30 -1 mean))&quot; &quot;(in-ns 'financial-senti.mongo)&quot; &quot;(mean [1])&quot; &quot;(mean [\&quot;1\&quot;])&quot; &quot;(s/meian [1])&quot; &quot;(s/median [1])&quot; &quot;(s/mean [1])&quot; &quot;(defn filter-nil\n  [func]\n  (fn [input]\n    (let [l (remove nil? input)]\n      (when (first l)\n        (func l)))))&quot; &quot;(defn to-catch\n  [func]\n  (fn [input]\n    (-&gt;&gt; input\n         (map (ignore-nil read-string))\n         (#((filter-nil func) %))\n         )))&quot; &quot;(def median (to-catch s/median))&quot; &quot;(def mean (to-catch s/mean))&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :news_before_30_test\n  :_id count-before-30)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :senti_ess_before_30_mean\n  :_id ess-before-30-mean)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :news_before_30\n  :_id count-before-30)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :senti_ess_before_30_median\n  :_id ess-before-30-median)&quot; &quot;(defn is-not-press-release\n  [value]\n  (not ((= value \&quot;PRESS-RELEASE\&quot;))))&quot; &quot;(ensure-index \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n              :news_type 1)&quot; &quot;(def the-filter-2\n  (sentiment [:rp_story_id :news_type] filter-func))&quot; &quot;(def count-before-30\n  (the-filter :zz -30 -1 count))&quot; &quot;(def ess-before-30-median\n  (the-filter :ess -30 -1 median))&quot; &quot;(def ess-before-30-mean\n  (the-filter :ess -30 -1 mean))&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :news_b30_pr\n  :_id count-before-30)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :senti_ess_b30_mean_pr\n  :_id ess-before-30-mean)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :senti_ess_b30_median_pr\n  :_id ess-before-30-median)&quot; &quot;(defn is-not-press-release\n  [value]\n  (not (= value \&quot;PRESS-RELEASE\&quot;)))&quot; &quot;(def filter-func-2\n  (filter-by-other-conds is-not-press-release))&quot; &quot;(def the-filter-2\n  (sentiment [:rp_story_id :news_type] filter-func-2))&quot; &quot;(def count-before-30\n  (the-filter-2 :zz -30 -1 count))&quot; &quot;(def ess-before-30-mean\n  (the-filter-2 :ess -30 -1 mean))&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :news_b30_npr\n  :_id count-before-30)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :senti_ess_b30_mean_npr\n  :_id ess-before-30-mean)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :senti_ess_b30_median_npr\n  :_id ess-before-30-median)&quot; &quot;(defn always-true\n  [value]\n  true)&quot; &quot;(def filter-func-3\n  (filter-by-other-conds always-true))&quot; &quot;(def the-filter-3\n  (sentiment [:rp_story_id :news_type] filter-func-3))&quot; &quot;(def count-before-30\n  (the-filter-3 :zz -30 -1 count))&quot; &quot;(def ess-before-30-median\n  (the-filter-2 :ess -30 -1 median))&quot; &quot;(def ess-before-30-median\n  (the-filter-3 :ess -30 -1 median))&quot; &quot;(def ess-before-30-mean\n  (the-filter-3 :ess -30 -1 mean))&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :news_b30_all\n  :_id count-before-30)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :senti_ess_b30_mean_all\n  :_id ess-before-30-mean)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :senti_ess_b30_median_all\n  :_id ess-before-30-median)&quot; &quot;(def filter-func\n  (filter-by-other-conds is-press-release))&quot; &quot;(def the-filter\n  (sentiment [:rp_story_id :news_type] filter-func))&quot; &quot;(def count-before-20\n  (the-filter :zz -20 -1 count))&quot; &quot;(def ess-before-20-median\n  (the-filter :ess -20 -1 median))&quot; &quot;(def ess-before-20-mean\n  (the-filter :ess -20 -1 mean))&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :news_b20_pr\n  :_id count-before-20)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :senti_ess_b20_mean_pr\n  :_id ess-before-20-mean)&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:date :permno_new] :senti_ess_b20_median_pr\n  :_id ess-before-20-median)&quot; &quot;(str :hehe)&quot; &quot;(keyword \&quot;a\&quot;)&quot; &quot;(defn start-all\n  [target db coll]\n  (let [method {\&quot;count\&quot; count\n                \&quot;median\&quot; median\n                \&quot;mean\&quot; mean}\n        news-type {\&quot;pr\&quot; is-press-release\n                   \&quot;npr\&quot; is-not-press-release\n                   \&quot;all\&quot; always-true}\n        time {\&quot;5\&quot; -5\n              \&quot;10\&quot; -10\n              \&quot;15\&quot; -15\n              \&quot;20\&quot; -20\n              \&quot;25\&quot; -25\n              \&quot;30\&quot; -30}]\n    (for [stat [\&quot;count\&quot; \&quot;median\&quot; \&quot;mean\&quot;]\n          range [ \&quot;5\&quot; \&quot;10\&quot; \&quot;15\&quot; \&quot;20\&quot; \&quot;25\&quot; \&quot;30\&quot;]\n          type [\&quot;pr\&quot; \&quot;npr\&quot; \&quot;all\&quot;]]\n      (let [filter-func (filter-by-other-conds (get news-type type))\n            the-filter (sentiment [:rp_story_id :news_type] filter-func)\n            before (the-filter (keyword target) (get time range) -1 (get method stat))]\n        (convert-variables\n          db coll\n          [:date :permno_new] (keyword (str target \&quot;_\&quot; stat \&quot;_b\&quot; range \&quot;_\&quot; type))\n          :_id\n          before)))))&quot; &quot;(start-all \&quot;ess\&quot; \&quot;finance\&quot; \&quot;fisd\&quot;)&quot; &quot;(defn start-all\n  [db coll]\n  (let [method {\&quot;count\&quot;  count\n                \&quot;median\&quot; median\n                \&quot;mean\&quot;   mean}\n        news-type {\&quot;pr\&quot;  is-press-release\n                   \&quot;npr\&quot; is-not-press-release\n                   \&quot;all\&quot; always-true}\n        time {\&quot;5\&quot;  -5\n              \&quot;10\&quot; -10\n              \&quot;15\&quot; -15\n              \&quot;20\&quot; -20\n              \&quot;25\&quot; -25\n              \&quot;30\&quot; -30}]\n    (doseq [range [\&quot;5\&quot; \&quot;10\&quot; \&quot;15\&quot; \&quot;20\&quot; \&quot;25\&quot; \&quot;30\&quot;]\n            target [\&quot;ess\&quot; \&quot;aes\&quot;]\n            type [\&quot;pr\&quot; \&quot;npr\&quot; \&quot;all\&quot;]\n            stat [\&quot;count\&quot; \&quot;median\&quot; \&quot;mean\&quot;]]\n      (let [filter-func (filter-by-other-conds (get news-type type))\n            the-filter (sentiment [:rp_story_id :news_type] filter-func)\n            before (the-filter (keyword target) (get time range) -1 (get method stat))]\n        (convert-variables\n          db coll\n          [:date :permno_new] (keyword (str target \&quot;_\&quot; stat \&quot;_b\&quot; range \&quot;_\&quot; type))\n          :_id\n          before)))))&quot; &quot;(ns financial-senti.mongo\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [monger.operators :refer :all]\n            [clojure.java.io :as io]\n            [clojure.data.csv :as csv]\n            [financial-senti.time :as t]\n            [incanter.stats :as s])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           org.bson.types.ObjectId))\n\n#_(defn directory\n    []\n    (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export\&quot;))\n\n(defn directory\n  []\n  (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export2\&quot;))\n\n\n(defn files\n  []\n  (file-seq (directory)))\n\n(defn lazy-read-csv\n  [csv-file]\n  (let [in-file (io/reader csv-file)\n        csv-seq (csv/read-csv in-file)\n        lazy (fn lazy [wrapped]\n               (lazy-seq\n                 (if-let [s (seq wrapped)]\n                   (cons (first s) (lazy (rest s)))\n                   (.close in-file))))]\n    (lazy csv-seq)))\n\n(defn lazy-read-csv-head-on\n  [file]\n  (let [coll (lazy-read-csv file)\n        head (map keyword (first coll))\n        rows (rest coll)]\n    (map #(zipmap head %) rows)))\n\n(defn write-to-mongo-in-batch\n  [db coll lazy-data]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/insert-batch db coll lazy-data)))\n\n(defn write-first-to-mongo\n  [db coll]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        f (first (rest (files)))]\n    (doseq [d (lazy-read-csv-head-on f)]\n      (mc/insert db coll (assoc d :_id (ObjectId.))))))\n\n\n(defn unique-index\n  [db coll key]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (array-map key 1) {:unique true})))\n\n(defn ensure-index\n  [db coll &amp; keyvals]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (apply array-map keyvals))))\n\n\n#_(defn update-to-mongo\n    [db coll identi]\n    (let [conn (mg/connect)\n          db (mg/get-db conn db)\n          a (atom 0)]\n      (doseq [f (doall (rest (rest (files))))]\n        (doseq [d (lazy-read-csv-head-on f)]\n          (mc/update db coll {identi (get d identi)}\n                     {$set d} {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print d))))))\n\n(defn update-to-mongo\n  [db coll identi]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (doseq [f (doall (rest (files)))]\n      (doseq [d (lazy-read-csv-head-on f)]\n        (mc/update db coll {identi (get d identi)}\n                   {$set d} {:upsert true})\n        (swap! a inc)\n        (if (= 0 (mod @a 5000))\n          (print d))))))\n\n(defn convert-date\n  [db coll old-date new-date index]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-date (t/parse-date (get % old-date))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-date])))))\n\n(defn read-into-memory\n  \&quot;Used to read unique values of 2 fields into memory\&quot;\n  [db coll &amp; ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (apply\n      (partial conj {})\n      (doall\n        (map\n          (apply juxt ks)\n          (mc/find-maps db coll {} ks))))))\n\n(defn find-one\n  [db coll cond ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/find-one-as-map db coll cond ks)))\n\n(defn convert-variable\n  [db coll old-v new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func (get % old-v))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-v])))))\n\n(defn convert-variables\n  [db coll old-vs new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func ((apply juxt old-vs)\n                                          %))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} (conj old-vs index))))))\n\n(def index (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno\n  [isin]\n  (when (&gt; (count isin) 8)\n    (let [issuer_cusip (subs isin 2 8)]\n      (get index issuer_cusip))))\n\n(def index2 (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno-general\n  [index key [head end]]\n  (when (&gt; (count key) 8)\n    (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip))))\n\n(def match-cusip-permno\n  (fn [cusip]\n    (match-permno-general index2 cusip [0 6])))\n\n(defn match-isin-permno\n  [isin]\n  (match-permno-general index2 isin [2 8]))\n\n\n\n(defn query-date-span\n  [db coll date-v match-v]                         ;target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [target-v start end stat-func]             ;time span\n      (fn [[date match]]                           ;function as input of convert-variables\n        (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n          (let [span (t/date-span start end date)]\n            (-&gt;&gt;\n              (mc/find-maps\n                db coll\n                {match-v match\n                 date-v  {$gte (first span)\n                          $lte (second span)}}\n                [target-v])\n              (map target-v)\n              stat-func)))))))\n\n(defn query-cond-date-span\n  [db coll date-v match-v]                                  ;define target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [cond-vs filter-func]                               ;define conditions by other variables\n      (fn [target-v start end stat-func]                    ;define time span\n        (fn [[date match]]                                  ;return function as input of function convert-variables\n          (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n            (let [span (t/date-span start end date)]\n              (-&gt;&gt;\n                (mc/find-maps\n                  db coll\n                  {match-v match\n                   date-v  {$gte (first span)\n                            $lte (second span)}}\n                  (conj cond-vs target-v))\n                (filter-func cond-vs target-v)\n                stat-func))))))))\n\n\n(defn ignore-nil\n  [func]\n  (fn [input]\n    (when (and input (&gt; (count input) 0))\n      (func input))))\n\n(defn filter-nil\n  [func]\n  (fn [input]\n    (let [l (remove nil? input)]\n      (when (first l)\n        (func l)))))\n\n\n(defn to-catch\n  [func]\n  (fn [input]\n    (-&gt;&gt; input\n         (map (ignore-nil read-string))\n         (#((filter-nil func) %))\n         )))\n\n(def median (to-catch s/median))\n(def mean (to-catch s/mean))\n\n\n(defn filter-by-other-conds\n  [pred-func]\n  (fn [[unique-v filter-v] target-v data]\n    (let [data (filter\n                 #(pred-func (get % filter-v))\n                 data)\n          acm {target-v [] unique-v #{}}]\n      (get\n        (reduce\n          (fn [acm el]\n            (let [a (target-v acm)\n                  b (unique-v acm)\n                  c (target-v el)\n                  d (unique-v el)]\n              (if (get b d)\n                {target-v a unique-v b}\n                {target-v (conj a c) unique-v (conj b d)})))\n          acm data)\n        target-v))))\n\n(defn is-press-release\n  [value]\n  (= value \&quot;PRESS-RELEASE\&quot;))\n\n(defn is-not-press-release\n  [value]\n  (not (= value \&quot;PRESS-RELEASE\&quot;)))\n\n(defn always-true\n  [value]\n  true)\n&quot; &quot;(defn start-all\n  [db coll]\n  (let [method {\&quot;count\&quot;  count\n                \&quot;median\&quot; median\n                \&quot;mean\&quot;   mean}\n        news-type {\&quot;pr\&quot;  is-press-release\n                   \&quot;npr\&quot; is-not-press-release\n                   \&quot;all\&quot; always-true}\n        time {\&quot;5\&quot;  -5\n              \&quot;10\&quot; -10\n              \&quot;15\&quot; -15\n              \&quot;20\&quot; -20\n              \&quot;25\&quot; -25\n              \&quot;30\&quot; -30\n              \&quot;45\&quot; -45\n              \&quot;60\&quot; -60}]\n    (doseq [range [\&quot;5\&quot; \&quot;10\&quot; \&quot;15\&quot; \&quot;20\&quot; \&quot;25\&quot; \&quot;30\&quot;]\n            target [\&quot;ess\&quot; \&quot;aes\&quot;]\n            type [\&quot;pr\&quot; \&quot;npr\&quot; \&quot;all\&quot;]\n            stat [\&quot;count\&quot; \&quot;median\&quot; \&quot;mean\&quot;]]\n      (let [filter-func (filter-by-other-conds (get news-type type))\n            the-filter (sentiment [:rp_story_id :news_type] filter-func)\n            before (the-filter (keyword target) (get time range) -1 (get method stat))]\n        (convert-variables\n          db coll\n          [:date :permno_new] (keyword (str target \&quot;_\&quot; stat \&quot;_b\&quot; range \&quot;_\&quot; type))\n          :_id\n          before)))))&quot; &quot;(ns financial-senti.mongo\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [monger.operators :refer :all]\n            [clojure.java.io :as io]\n            [clojure.data.csv :as csv]\n            [financial-senti.time :as t]\n            [incanter.stats :as s])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           org.bson.types.ObjectId))\n\n#_(defn directory\n    []\n    (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export\&quot;))\n\n(defn directory\n  []\n  (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export2\&quot;))\n\n\n(defn files\n  []\n  (file-seq (directory)))\n\n(defn lazy-read-csv\n  [csv-file]\n  (let [in-file (io/reader csv-file)\n        csv-seq (csv/read-csv in-file)\n        lazy (fn lazy [wrapped]\n               (lazy-seq\n                 (if-let [s (seq wrapped)]\n                   (cons (first s) (lazy (rest s)))\n                   (.close in-file))))]\n    (lazy csv-seq)))\n\n(defn lazy-read-csv-head-on\n  [file]\n  (let [coll (lazy-read-csv file)\n        head (map keyword (first coll))\n        rows (rest coll)]\n    (map #(zipmap head %) rows)))\n\n(defn write-to-mongo-in-batch\n  [db coll lazy-data]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/insert-batch db coll lazy-data)))\n\n(defn write-first-to-mongo\n  [db coll]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        f (first (rest (files)))]\n    (doseq [d (lazy-read-csv-head-on f)]\n      (mc/insert db coll (assoc d :_id (ObjectId.))))))\n\n\n(defn unique-index\n  [db coll key]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (array-map key 1) {:unique true})))\n\n(defn ensure-index\n  [db coll &amp; keyvals]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (apply array-map keyvals))))\n\n\n#_(defn update-to-mongo\n    [db coll identi]\n    (let [conn (mg/connect)\n          db (mg/get-db conn db)\n          a (atom 0)]\n      (doseq [f (doall (rest (rest (files))))]\n        (doseq [d (lazy-read-csv-head-on f)]\n          (mc/update db coll {identi (get d identi)}\n                     {$set d} {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print d))))))\n\n(defn update-to-mongo\n  [db coll identi]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (doseq [f (doall (rest (files)))]\n      (doseq [d (lazy-read-csv-head-on f)]\n        (mc/update db coll {identi (get d identi)}\n                   {$set d} {:upsert true})\n        (swap! a inc)\n        (if (= 0 (mod @a 5000))\n          (print d))))))\n\n(defn convert-date\n  [db coll old-date new-date index]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-date (t/parse-date (get % old-date))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-date])))))\n\n(defn read-into-memory\n  \&quot;Used to read unique values of 2 fields into memory\&quot;\n  [db coll &amp; ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (apply\n      (partial conj {})\n      (doall\n        (map\n          (apply juxt ks)\n          (mc/find-maps db coll {} ks))))))\n\n(defn find-one\n  [db coll cond ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/find-one-as-map db coll cond ks)))\n\n(defn convert-variable\n  [db coll old-v new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func (get % old-v))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-v])))))\n\n(defn convert-variables\n  [db coll old-vs new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func ((apply juxt old-vs)\n                                          %))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} (conj old-vs index))))))\n\n(def index (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno\n  [isin]\n  (when (&gt; (count isin) 8)\n    (let [issuer_cusip (subs isin 2 8)]\n      (get index issuer_cusip))))\n\n(def index2 (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno-general\n  [index key [head end]]\n  (when (&gt; (count key) 8)\n    (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip))))\n\n(def match-cusip-permno\n  (fn [cusip]\n    (match-permno-general index2 cusip [0 6])))\n\n(defn match-isin-permno\n  [isin]\n  (match-permno-general index2 isin [2 8]))\n\n\n\n(defn query-date-span\n  [db coll date-v match-v]                         ;target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [target-v start end stat-func]             ;time span\n      (fn [[date match]]                           ;function as input of convert-variables\n        (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n          (let [span (t/date-span start end date)]\n            (-&gt;&gt;\n              (mc/find-maps\n                db coll\n                {match-v match\n                 date-v  {$gte (first span)\n                          $lte (second span)}}\n                [target-v])\n              (map target-v)\n              stat-func)))))))\n\n(defn query-cond-date-span\n  [db coll date-v match-v]                                  ;define target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [cond-vs filter-func]                               ;define conditions by other variables\n      (fn [target-v start end stat-func]                    ;define time span\n        (fn [[date match]]                                  ;return function as input of function convert-variables\n          (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n            (let [span (t/date-span start end date)]\n              (-&gt;&gt;\n                (mc/find-maps\n                  db coll\n                  {match-v match\n                   date-v  {$gte (first span)\n                            $lte (second span)}}\n                  (conj cond-vs target-v))\n                (filter-func cond-vs target-v)\n                stat-func))))))))\n\n\n(defn ignore-nil\n  [func]\n  (fn [input]\n    (when (and input (&gt; (count input) 0))\n      (func input))))\n\n(defn filter-nil\n  [func]\n  (fn [input]\n    (let [l (remove nil? input)]\n      (when (first l)\n        (func l)))))\n\n\n(defn to-catch\n  [func]\n  (fn [input]\n    (-&gt;&gt; input\n         (map (ignore-nil read-string))\n         (#((filter-nil func) %))\n         )))\n\n(def median (to-catch s/median))\n(def mean (to-catch s/mean))\n\n\n(defn filter-by-other-conds\n  [pred-func]\n  (fn [[unique-v filter-v] target-v data]\n    (let [data (filter\n                 #(pred-func (get % filter-v))\n                 data)\n          acm {target-v [] unique-v #{}}]\n      (get\n        (reduce\n          (fn [acm el]\n            (let [a (target-v acm)\n                  b (unique-v acm)\n                  c (target-v el)\n                  d (unique-v el)]\n              (if (get b d)\n                {target-v a unique-v b}\n                {target-v (conj a c) unique-v (conj b d)})))\n          acm data)\n        target-v))))\n\n(defn is-press-release\n  [value]\n  (= value \&quot;PRESS-RELEASE\&quot;))\n\n(defn is-not-press-release\n  [value]\n  (not (= value \&quot;PRESS-RELEASE\&quot;)))\n\n(defn always-true\n  [value]\n  true)&quot; &quot;(def sentiment\n  (query-cond-date-span\n    \&quot;finance\&quot; \&quot;rpus_rv\&quot;\n    :date :permno))&quot; &quot;(defn start-all\n  [db coll]\n  (let [method {\&quot;count\&quot;  count\n                \&quot;median\&quot; median\n                \&quot;mean\&quot;   mean}\n        news-type {\&quot;pr\&quot;  is-press-release\n                   \&quot;npr\&quot; is-not-press-release\n                   \&quot;all\&quot; always-true}\n        time {\&quot;5\&quot;  -5\n              \&quot;10\&quot; -10\n              \&quot;15\&quot; -15\n              \&quot;20\&quot; -20\n              \&quot;25\&quot; -25\n              \&quot;30\&quot; -30\n              \&quot;45\&quot; -45\n              \&quot;60\&quot; -60}]\n    (doseq [range [\&quot;5\&quot; \&quot;10\&quot; \&quot;15\&quot; \&quot;20\&quot; \&quot;25\&quot; \&quot;30\&quot; \&quot;45\&quot; \&quot;60\&quot;]\n            target [\&quot;ess\&quot; \&quot;aes\&quot;]\n            type [\&quot;pr\&quot; \&quot;npr\&quot; \&quot;all\&quot;]\n            stat [\&quot;count\&quot; \&quot;median\&quot; \&quot;mean\&quot;]]\n      (let [filter-func (filter-by-other-conds (get news-type type))\n            the-filter (sentiment [:rp_story_id :news_type] filter-func)\n            before (the-filter (keyword target) (get time range) -1 (get method stat))]\n        (convert-variables\n          db coll\n          [:date :permno_new] (keyword (str target \&quot;_\&quot; stat \&quot;_b\&quot; range \&quot;_\&quot; type))\n          :_id\n          before)))))&quot; &quot;(start-all \&quot;finance\&quot; \&quot;fisd\&quot;)&quot; &quot;(defn write-csv-quoted\n  [coll file &amp; {:keys [append encoding]}]\n  (let [keys-vec (keys (first coll))\n        vals-vecs (map (apply juxt keys-vec) coll)]\n    (with-open [out (io/writer file :append append :encoding encoding)]\n      (binding [*out* out]\n        (when-not append\n          (print (clj-csv/write-csv (vector (map name keys-vec)) :force-quote true)))\n        (doseq [v vals-vecs]\n          (let [v (map str v)]\n            (print (clj-csv/write-csv (vector v) :force-quote true))))))))&quot; &quot;(defn dump-mongo-to-csv\n  [db coll file]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (write-csv-quoted (mc/find-maps db coll)\n                      file)))&quot; &quot;(dump-mongo-to-csv \&quot;finance\&quot; \&quot;fisd\&quot;\n                   \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\fisd_matched.csv\&quot;)&quot; &quot;(ns financial-senti.mongo\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [monger.operators :refer :all]\n            [clojure.java.io :as io]\n            [clojure.data.csv :as csv]\n            [financial-senti.time :as t]\n            [incanter.stats :as s]\n            [clojure-csv.core :as clj-csv])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           org.bson.types.ObjectId))&quot; &quot;(ns financial-senti.mongo\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [monger.operators :refer :all]\n            [clojure.java.io :as io]\n            [clojure.data.csv :as csv]\n            [financial-senti.time :as t]\n            [incanter.stats :as s]\n            [clojure-csv.core :as clj-csv])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           org.bson.types.ObjectId))\n\n#_(defn directory\n    []\n    (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export\&quot;))\n\n(defn directory\n  []\n  (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export2\&quot;))\n\n\n(defn files\n  []\n  (file-seq (directory)))\n\n(defn lazy-read-csv\n  [csv-file]\n  (let [in-file (io/reader csv-file)\n        csv-seq (csv/read-csv in-file)\n        lazy (fn lazy [wrapped]\n               (lazy-seq\n                 (if-let [s (seq wrapped)]\n                   (cons (first s) (lazy (rest s)))\n                   (.close in-file))))]\n    (lazy csv-seq)))\n\n(defn lazy-read-csv-head-on\n  [file]\n  (let [coll (lazy-read-csv file)\n        head (map keyword (first coll))\n        rows (rest coll)]\n    (map #(zipmap head %) rows)))\n\n(defn write-to-mongo-in-batch\n  [db coll lazy-data]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/insert-batch db coll lazy-data)))\n\n(defn write-first-to-mongo\n  [db coll]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        f (first (rest (files)))]\n    (doseq [d (lazy-read-csv-head-on f)]\n      (mc/insert db coll (assoc d :_id (ObjectId.))))))\n\n\n(defn unique-index\n  [db coll key]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (array-map key 1) {:unique true})))\n\n(defn ensure-index\n  [db coll &amp; keyvals]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (apply array-map keyvals))))\n\n\n#_(defn update-to-mongo\n    [db coll identi]\n    (let [conn (mg/connect)\n          db (mg/get-db conn db)\n          a (atom 0)]\n      (doseq [f (doall (rest (rest (files))))]\n        (doseq [d (lazy-read-csv-head-on f)]\n          (mc/update db coll {identi (get d identi)}\n                     {$set d} {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print d))))))\n\n(defn update-to-mongo\n  [db coll identi]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (doseq [f (doall (rest (files)))]\n      (doseq [d (lazy-read-csv-head-on f)]\n        (mc/update db coll {identi (get d identi)}\n                   {$set d} {:upsert true})\n        (swap! a inc)\n        (if (= 0 (mod @a 5000))\n          (print d))))))\n\n(defn convert-date\n  [db coll old-date new-date index]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-date (t/parse-date (get % old-date))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-date])))))\n\n(defn read-into-memory\n  \&quot;Used to read unique values of 2 fields into memory\&quot;\n  [db coll &amp; ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (apply\n      (partial conj {})\n      (doall\n        (map\n          (apply juxt ks)\n          (mc/find-maps db coll {} ks))))))\n\n(defn find-one\n  [db coll cond ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/find-one-as-map db coll cond ks)))\n\n(defn convert-variable\n  [db coll old-v new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func (get % old-v))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-v])))))\n\n(defn convert-variables\n  [db coll old-vs new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func ((apply juxt old-vs)\n                                          %))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} (conj old-vs index))))))\n\n(def index (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno\n  [isin]\n  (when (&gt; (count isin) 8)\n    (let [issuer_cusip (subs isin 2 8)]\n      (get index issuer_cusip))))\n\n(def index2 (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno-general\n  [index key [head end]]\n  (when (&gt; (count key) 8)\n    (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip))))\n\n(def match-cusip-permno\n  (fn [cusip]\n    (match-permno-general index2 cusip [0 6])))\n\n(defn match-isin-permno\n  [isin]\n  (match-permno-general index2 isin [2 8]))\n\n\n\n(defn query-date-span\n  [db coll date-v match-v]                         ;target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [target-v start end stat-func]             ;time span\n      (fn [[date match]]                           ;function as input of convert-variables\n        (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n          (let [span (t/date-span start end date)]\n            (-&gt;&gt;\n              (mc/find-maps\n                db coll\n                {match-v match\n                 date-v  {$gte (first span)\n                          $lte (second span)}}\n                [target-v])\n              (map target-v)\n              stat-func)))))))\n\n(defn query-cond-date-span\n  [db coll date-v match-v]                                  ;define target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [cond-vs filter-func]                               ;define conditions by other variables\n      (fn [target-v start end stat-func]                    ;define time span\n        (fn [[date match]]                                  ;return function as input of function convert-variables\n          (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n            (let [span (t/date-span start end date)]\n              (-&gt;&gt;\n                (mc/find-maps\n                  db coll\n                  {match-v match\n                   date-v  {$gte (first span)\n                            $lte (second span)}}\n                  (conj cond-vs target-v))\n                (filter-func cond-vs target-v)\n                stat-func))))))))\n\n\n(defn ignore-nil\n  [func]\n  (fn [input]\n    (when (and input (&gt; (count input) 0))\n      (func input))))\n\n(defn filter-nil\n  [func]\n  (fn [input]\n    (let [l (remove nil? input)]\n      (when (first l)\n        (func l)))))\n\n\n(defn to-catch\n  [func]\n  (fn [input]\n    (-&gt;&gt; input\n         (map (ignore-nil read-string))\n         (#((filter-nil func) %))\n         )))\n\n(def median (to-catch s/median))\n(def mean (to-catch s/mean))\n\n\n(defn filter-by-other-conds\n  [pred-func]\n  (fn [[unique-v filter-v] target-v data]\n    (let [data (filter\n                 #(pred-func (get % filter-v))\n                 data)\n          acm {target-v [] unique-v #{}}]\n      (get\n        (reduce\n          (fn [acm el]\n            (let [a (target-v acm)\n                  b (unique-v acm)\n                  c (target-v el)\n                  d (unique-v el)]\n              (if (get b d)\n                {target-v a unique-v b}\n                {target-v (conj a c) unique-v (conj b d)})))\n          acm data)\n        target-v))))\n\n(defn is-press-release\n  [value]\n  (= value \&quot;PRESS-RELEASE\&quot;))\n\n(defn is-not-press-release\n  [value]\n  (not (= value \&quot;PRESS-RELEASE\&quot;)))\n\n(defn always-true\n  [value]\n  true)\n\n\n(defn write-csv-quoted\n  [coll file &amp; {:keys [append encoding]}]\n  (let [keys-vec (keys (first coll))\n        vals-vecs (map (apply juxt keys-vec) coll)]\n    (with-open [out (io/writer file :append append :encoding encoding)]\n      (binding [*out* out]\n        (when-not append\n          (print (clj-csv/write-csv (vector (map name keys-vec)) :force-quote true)))\n        (doseq [v vals-vecs]\n          (let [v (map str v)]\n            (print (clj-csv/write-csv (vector v) :force-quote true))))))))\n\n(defn dump-mongo-to-csv\n  [db coll file]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (write-csv-quoted (mc/find-maps db coll)\n                      file)))\n&quot; &quot;(lazy-read-csv-head-on\n  \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\debt_rating.csv\&quot;)&quot; &quot;(write-to-mongo-in-batch\n  \&quot;finance\&quot; \&quot;debt_rating\&quot;\n  (lazy-read-csv-head-on\n  \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\debt_rating.csv\&quot;))&quot; &quot;(cond false true)&quot; &quot;(defn integrate-rating\n  [[mr sp fitch]]\n  (let [db (partial read-into-memory \&quot;finance\&quot; \&quot;debt_rating\&quot;)\n        mr-c (db :mr :rating)\n        sp-c (db :sp :rating)\n        fitch-c (db :fitch :rating)\n        func #(or (= % \&quot;\&quot;) (nil? %))]\n    (cond\n      (func mr) (get mr-c mr)\n      (func sp) (get sp-c sp)\n      (func fitch) (get fitch-c fitch))))&quot; &quot;(ns financial-senti.mongo\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [monger.operators :refer :all]\n            [clojure.java.io :as io]\n            [clojure.data.csv :as csv]\n            [financial-senti.time :as t]\n            [incanter.stats :as s]\n            [clojure-csv.core :as clj-csv])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           org.bson.types.ObjectId))\n\n#_(defn directory\n    []\n    (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export\&quot;))\n\n(defn directory\n  []\n  (io/file \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\export2\&quot;))\n\n\n(defn files\n  []\n  (file-seq (directory)))\n\n(defn lazy-read-csv\n  [csv-file]\n  (let [in-file (io/reader csv-file)\n        csv-seq (csv/read-csv in-file)\n        lazy (fn lazy [wrapped]\n               (lazy-seq\n                 (if-let [s (seq wrapped)]\n                   (cons (first s) (lazy (rest s)))\n                   (.close in-file))))]\n    (lazy csv-seq)))\n\n(defn lazy-read-csv-head-on\n  [file]\n  (let [coll (lazy-read-csv file)\n        head (map keyword (first coll))\n        rows (rest coll)]\n    (map #(zipmap head %) rows)))\n\n(defn write-to-mongo-in-batch\n  [db coll lazy-data]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/insert-batch db coll lazy-data)))\n\n(defn write-first-to-mongo\n  [db coll]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        f (first (rest (files)))]\n    (doseq [d (lazy-read-csv-head-on f)]\n      (mc/insert db coll (assoc d :_id (ObjectId.))))))\n\n\n(defn unique-index\n  [db coll key]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (array-map key 1) {:unique true})))\n\n(defn ensure-index\n  [db coll &amp; keyvals]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/ensure-index db coll (apply array-map keyvals))))\n\n\n#_(defn update-to-mongo\n    [db coll identi]\n    (let [conn (mg/connect)\n          db (mg/get-db conn db)\n          a (atom 0)]\n      (doseq [f (doall (rest (rest (files))))]\n        (doseq [d (lazy-read-csv-head-on f)]\n          (mc/update db coll {identi (get d identi)}\n                     {$set d} {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print d))))))\n\n(defn update-to-mongo\n  [db coll identi]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (doseq [f (doall (rest (files)))]\n      (doseq [d (lazy-read-csv-head-on f)]\n        (mc/update db coll {identi (get d identi)}\n                   {$set d} {:upsert true})\n        (swap! a inc)\n        (if (= 0 (mod @a 5000))\n          (print d))))))\n\n(defn convert-date\n  [db coll old-date new-date index]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (map\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-date (t/parse-date (get % old-date))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-date])))))\n\n(defn read-into-memory\n  \&quot;Used to read unique values of 2 fields into memory\&quot;\n  [db coll &amp; ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (apply\n      (partial conj {})\n      (doall\n        (map\n          (apply juxt ks)\n          (mc/find-maps db coll {} ks))))))\n\n(defn find-one\n  [db coll cond ks]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (mc/find-one-as-map db coll cond ks)))\n\n(defn convert-variable\n  [db coll old-v new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func (get % old-v))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} [index old-v])))))\n\n(defn convert-variables\n  [db coll old-vs new-v index func]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)\n        a (atom 0)]\n    (dorun\n      (pmap\n        #(do\n          (mc/update db coll {index (get % index)}\n                     {$set {new-v (func ((apply juxt old-vs)\n                                          %))}}\n                     {:upsert true})\n          (swap! a inc)\n          (if (= 0 (mod @a 5000))\n            (print %)))\n        (mc/find-maps db coll {} (conj old-vs index))))))\n\n(def index (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno\n  [isin]\n  (when (&gt; (count isin) 8)\n    (let [issuer_cusip (subs isin 2 8)]\n      (get index issuer_cusip))))\n\n(def index2 (read-into-memory \&quot;finance\&quot; \&quot;index\&quot;\n                             :issuer_cusip\n                             :permno))\n\n(defn match-permno-general\n  [index key [head end]]\n  (when (&gt; (count key) 8)\n    (let [issuer_cusip (subs key head end)]\n      (get index issuer_cusip))))\n\n(def match-cusip-permno\n  (fn [cusip]\n    (match-permno-general index2 cusip [0 6])))\n\n(defn match-isin-permno\n  [isin]\n  (match-permno-general index2 isin [2 8]))\n\n\n\n(defn query-date-span\n  [db coll date-v match-v]                         ;target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [target-v start end stat-func]             ;time span\n      (fn [[date match]]                           ;function as input of convert-variables\n        (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n          (let [span (t/date-span start end date)]\n            (-&gt;&gt;\n              (mc/find-maps\n                db coll\n                {match-v match\n                 date-v  {$gte (first span)\n                          $lte (second span)}}\n                [target-v])\n              (map target-v)\n              stat-func)))))))\n\n(defn query-cond-date-span\n  [db coll date-v match-v]                                  ;define target collection\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (fn [cond-vs filter-func]                               ;define conditions by other variables\n      (fn [target-v start end stat-func]                    ;define time span\n        (fn [[date match]]                                  ;return function as input of function convert-variables\n          (when (and match (or (not (string? match)) (&gt; (count match) 0)))\n            (let [span (t/date-span start end date)]\n              (-&gt;&gt;\n                (mc/find-maps\n                  db coll\n                  {match-v match\n                   date-v  {$gte (first span)\n                            $lte (second span)}}\n                  (conj cond-vs target-v))\n                (filter-func cond-vs target-v)\n                stat-func))))))))\n\n\n(defn ignore-nil\n  [func]\n  (fn [input]\n    (when (and input (&gt; (count input) 0))\n      (func input))))\n\n(defn filter-nil\n  [func]\n  (fn [input]\n    (let [l (remove nil? input)]\n      (when (first l)\n        (func l)))))\n\n\n(defn to-catch\n  [func]\n  (fn [input]\n    (-&gt;&gt; input\n         (map (ignore-nil read-string))\n         (#((filter-nil func) %))\n         )))\n\n(def median (to-catch s/median))\n(def mean (to-catch s/mean))\n\n\n(defn filter-by-other-conds\n  [pred-func]\n  (fn [[unique-v filter-v] target-v data]\n    (let [data (filter\n                 #(pred-func (get % filter-v))\n                 data)\n          acm {target-v [] unique-v #{}}]\n      (get\n        (reduce\n          (fn [acm el]\n            (let [a (target-v acm)\n                  b (unique-v acm)\n                  c (target-v el)\n                  d (unique-v el)]\n              (if (get b d)\n                {target-v a unique-v b}\n                {target-v (conj a c) unique-v (conj b d)})))\n          acm data)\n        target-v))))\n\n(defn is-press-release\n  [value]\n  (= value \&quot;PRESS-RELEASE\&quot;))\n\n(defn is-not-press-release\n  [value]\n  (not (= value \&quot;PRESS-RELEASE\&quot;)))\n\n(defn always-true\n  [value]\n  true)\n\n\n(defn write-csv-quoted\n  [coll file &amp; {:keys [append encoding]}]\n  (let [keys-vec (keys (first coll))\n        vals-vecs (map (apply juxt keys-vec) coll)]\n    (with-open [out (io/writer file :append append :encoding encoding)]\n      (binding [*out* out]\n        (when-not append\n          (print (clj-csv/write-csv (vector (map name keys-vec)) :force-quote true)))\n        (doseq [v vals-vecs]\n          (let [v (map str v)]\n            (print (clj-csv/write-csv (vector v) :force-quote true))))))))\n\n(defn dump-mongo-to-csv\n  [db coll file]\n  (let [conn (mg/connect)\n        db (mg/get-db conn db)]\n    (write-csv-quoted (mc/find-maps db coll)\n                      file)))\n\n(def rating-search (partial read-into-memory \&quot;finance\&quot; \&quot;debt_rating\&quot;))\n(def mr-c (rating-search :mr :rating))\n(def sp-c (rating-search :sp :rating))\n(def fitch-c (rating-search :fitch :rating))\n\n(defn integrate-rating\n  [[mr sp fitch]]\n  (let [func #(or (= % \&quot;\&quot;) (nil? %))]\n    (cond\n      (func mr) (get mr-c mr)\n      (func sp) (get sp-c sp)\n      (func fitch) (get fitch-c fitch))))\n&quot; &quot;(def mr-c (dissoc (rating-search :mr :rating) \&quot;\&quot;))&quot; &quot;(def sp-c (dissoc (rating-search :sp :rating) \&quot;\&quot;))&quot; &quot;(def fitch-c (dissoc (rating-search :fitch :rating) \&quot;\&quot;))&quot; &quot;mr-c&quot; &quot;sp-c&quot; &quot;fitch-c&quot; &quot;(cond true 1\n      true 2\n      fale 3)&quot; &quot;(cond true 1\n      true 2\n      false 3)&quot; &quot;(defn integrate-rating\n  [[mr sp fitch]]\n  (let [func #(not (or (= % \&quot;\&quot;) (nil? %)))]\n    (cond\n      (func mr) (get mr-c mr)\n      (func sp) (get sp-c sp)\n      (func fitch) (get fitch-c fitch))))&quot; &quot;(defn integrate-rating\n  [[mr sp fitch]]\n  (let [func #(not (or (= % \&quot;\&quot;) (nil? %)))]\n    (cond\n      (func sp) (get sp-c sp)\n      (func mr) (get mr-c mr)\n      (func fitch) (get fitch-c fitch))))&quot; &quot;(defn integrate-rating\n  [[sp mr fitch]]\n  (let [func #(not (or (= % \&quot;\&quot;) (nil? %)))]\n    (cond\n      (func sp) (get sp-c sp)\n      (func mr) (get mr-c mr)\n      (func fitch) (get fitch-c fitch))))&quot; &quot;(defn integrate-rating\n  [[sp mr fitch]]\n  (let [func #(not (or (= % \&quot;\&quot;) (nil? %) (= % \&quot;NR\&quot;)))\n        f2 #(= % \&quot;NR\&quot;)]\n    (cond\n      (func sp) (get sp-c sp)\n      (func mr) (get mr-c mr)\n      (func fitch) (get fitch-c fitch)\n      (f2 sp) (get sp-c sp)\n      (f2 mr) (get mr-c mr)\n      (f2 fitch) (get fitch-c fitch))))&quot; &quot;(convert-variables\n  \&quot;finance\&quot; \&quot;fisd\&quot;\n  [:rating_sp :rating_mr :rating_fitch] :rating\n  :_id\n  integrate-rating)&quot; &quot;(dump-mongo-to-csv \&quot;finance\&quot; \&quot;fisd\&quot;\n                   \&quot;C:\\\\Users\\\\Xue\\\\workspace\\\\econometric_stata\\\\raw_data\\\\fisd_matched.csv\&quot;)&quot;], :remote []}}</component>
</project>